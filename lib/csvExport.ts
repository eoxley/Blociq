import { saveAs } from 'file-saver';

export interface CSVExportData {
  [key: string]: string | number | boolean;
}

export interface CSVColumn {
  key: string;
  label: string;
}

/**
 * Export data to CSV file
 * @param data Array of objects to export
 * @param columns Column definitions with key and label
 * @param filename Name of the CSV file (without extension)
 */
export function exportToCSV(
  data: CSVExportData[], 
  columns: CSVColumn[], 
  filename: string
): void {
  if (data.length === 0) {
    console.warn('No data to export');
    return;
  }

  // Create header row
  const header = columns.map(col => `"${col.label}"`).join(',');
  
  // Create data rows
  const rows = data.map(row => 
    columns.map(col => {
      const value = row[col.key];
      // Escape quotes and wrap in quotes
      const escapedValue = String(value).replace(/"/g, '""');
      return `"${escapedValue}"`;
    }).join(',')
  );
  
  // Combine header and rows
  const csvContent = [header, ...rows].join('\n');
  
  // Create blob and download
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
  const timestamp = new Date().toISOString().split('T')[0];
  saveAs(blob, `${filename}_${timestamp}.csv`);
}

/**
 * Export recipients data specifically
 * @param recipients Array of recipient objects
 * @param filename Name of the CSV file (without extension)
 */
export function exportRecipientsToCSV(recipients: Record<string, unknown>[], filename: string = 'recipients'): void {
  const columns: CSVColumn[] = [
    { key: 'name', label: 'Name' },
    { key: 'email', label: 'Email' },
    { key: 'unit', label: 'Unit' },
    { key: 'type', label: 'Type' },
    { key: 'building_name', label: 'Building' }
  ];

  // Transform the data to ensure all values are strings, numbers, or booleans
  const transformedData: CSVExportData[] = recipients.map(recipient => ({
    name: String(recipient.name || ''),
    email: String(recipient.email || ''),
    unit: String(recipient.unit || ''),
    type: String(recipient.type || ''),
    building_name: String(recipient.building_name || '')
  }));

  exportToCSV(transformedData, columns, filename);
}

/**
 * Export communications log data
 * @param communications Array of communication objects
 * @param filename Name of the CSV file (without extension)
 */
export function exportCommunicationsToCSV(communications: Record<string, unknown>[], filename: string = 'communications'): void {
  const columns: CSVColumn[] = [
    { key: 'to_email', label: 'Recipient Email' },
    { key: 'subject', label: 'Subject' },
    { key: 'template_name', label: 'Template' },
    { key: 'building_name', label: 'Building' },
    { key: 'sent_by', label: 'Sent By' },
    { key: 'sent_at', label: 'Sent Date' },
    { key: 'status', label: 'Status' }
  ];

  // Transform the data to include formatted dates
  const transformedData = communications.map(comm => ({
    ...comm,
    sent_at: (() => {
      const sentAt = comm.sent_at;
      if (sentAt instanceof Date) {
        return sentAt.toLocaleDateString();
      }
      if (typeof sentAt === 'string' || typeof sentAt === 'number') {
        return new Date(sentAt).toLocaleDateString();
      }
      return 'Unknown Date';
    })()
  }));

  exportToCSV(transformedData, columns, filename);
}

/**
 * Export generated documents data
 * @param documents Array of document objects
 * @param filename Name of the CSV file (without extension)
 */
export function exportDocumentsToCSV(documents: Record<string, unknown>[], filename: string = 'generated_documents'): void {
  const columns: CSVColumn[] = [
    { key: 'template_name', label: 'Template' },
    { key: 'building_name', label: 'Building' },
    { key: 'filled_by', label: 'Generated By' },
    { key: 'created_at', label: 'Generated Date' },
    { key: 'ai_generated', label: 'AI Generated' }
  ];

  // Transform the data to include formatted dates and boolean values
  const transformedData = documents.map(doc => ({
    ...doc,
    created_at: (() => {
      const createdAt = doc.created_at;
      if (createdAt instanceof Date) {
        return createdAt.toLocaleDateString();
      }
      if (typeof createdAt === 'string' || typeof createdAt === 'number') {
        return new Date(createdAt).toLocaleDateString();
      }
      return 'Unknown Date';
    })(),
    ai_generated: doc.ai_generated ? 'Yes' : 'No'
  }));

  exportToCSV(transformedData, columns, filename);
} 